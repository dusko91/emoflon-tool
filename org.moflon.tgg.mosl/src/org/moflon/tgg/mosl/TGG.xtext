grammar org.moflon.tgg.mosl.TGG with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate tgg "http://www.moflon.org/ide/tgg/mosl/TGG"
//generate tgg "platform:/plugin/org.moflon.tgg.mosl/model/generated/TGG.ecore"

TripleGraphGrammarFile:
	(schema = Schema)?
  	(rules += Rule)*
  	(library = AttrCondDefLibrary)?
;

Schema:
	imports += Import*	
	'schema' name = ID
		
	('source' '{'
		sourceTypes += [ecore::EPackage | QualifiedName]*
	'}')? 
	
	('target' '{'
		targetTypes += [ecore::EPackage | QualifiedName]*
	'}')? 

	('correspondence' '{'
		correspondenceTypes += CorrType*
	'}')?	
	
	('attribute conditions' '{'
		attributeCondDefs += AttrCondDef*
	'}')? 
;

CorrType:
	(CorrTypeDef | TypeExtension)
;

TypeExtension:
	name = ID 'extends' super=[CorrType]
;

CorrTypeDef:
	name = ID '{'
		'-src->' source = [ecore::EClass | QualifiedName]  
		'-trg->' target = [ecore::EClass | QualifiedName]
	'}'
;

Rule:
	imports += Import*	
	(abstractRule ?= 'abstract')? 'rule' name = ID ('extends' supertypes += [Rule])? ' with ' schema = [Schema | QualifiedName]
		
	('source' '{'
		sourcePatterns += ObjectVariablePattern* 
	'}')? 	
	
	('target' '{'
		targetPatterns += ObjectVariablePattern* 
	'}')? 
	
	('correspondence' '{'
		correspondencePatterns += CorrVariablePattern*	
	'}')? 

	('attribute conditions' '{'
		attrConditions += AttrCond*
	'}')? 
;

AttrCond:
	name = [AttrCondDef] '(' (values += ParamValue (',' values += ParamValue)*)? ')'
;

//AttrCond:
//	name = [AttrCondDef] '(' (values += ParamValue (',' values += ParamValue)*)? ')' ( '{'
//		'sync:'
//			(allowedSyncAdornments += [Adornment] (',' allowedSyncAdornments += [Adornment] )*)?
//		'gen:'
//			(allowedGenAdornments += [Adornment] (',' allowedGenAdornments += [Adornment] )*)?
//	'}')?
//;

AttrCondDef:
	name = ID '(' (params += Param (',' params += Param)*)? ')' '{'
		'sync:'
			allowedSyncAdornments += Adornment (',' allowedSyncAdornments += Adornment)*
		'gen:'
			(allowedGenAdornments += Adornment (',' allowedGenAdornments += Adornment )*)?
	'}'
;
AttrCondDefLibrary:
	'library' name = QualifiedName
	('{'
		attributeCondDefs += AttrCondDef*
	'}')?
;

Adornment:
	value = ID
;

Param:
//	index = INT ':' type = [ecore::EDataType | QualifiedName]
	index = INT ':' (type = ID)?
;

ParamValue:
	(AttributeVariable | LocalVariable | Literal)
;

AttributeVariable:
	objectVar = [ObjectVariablePattern] '.' attribute = ID
;

LocalVariable:
	name = ID
;

Literal:
	value = LiteralValue
;

LiteralValue:
	(STRING | INT | DECIMAL)
;

terminal DECIMAL: INT '.' INT;

CorrVariablePattern:
	(op = Operator)? name = ID ' : ' type = [CorrType | QualifiedName] '{'
		'-src->' source = [ObjectVariablePattern]
		'-trg->' target = [ObjectVariablePattern]
	'}' 
;

ObjectVariablePattern:
	(op = Operator)? name = ID ' : ' type = [ecore::EClass | QualifiedName] ('{'
		attributeAssignments += AttributeAssignment*
		attributeConstraints += AttributeConstraint*
		linkVariablePatterns += LinkVariablePattern*
	'}')? 
;

AttributeConstraint:
	attribute = [ecore::EAttribute] op=ComparisonOperator valueExp = Expression
;

ComparisonOperator:
	(' == ' | ' != ' | ' <= ' | ' >= ' | ' > ' | ' < ')
;

AttributeAssignment:
//	attribute = AttributeVariable op=' := ' valueExp = Expression
	attribute = [ecore::EAttribute] op=' := ' valueExp = Expression
;

Expression:
	(LiteralExpression | AttributeExpression)
;

AttributeExpression:
	objectVar = [ObjectVariablePattern] '.' attribute = [ecore::EAttribute]
;

LiteralExpression:
	value = LiteralExpressionValue
;

LiteralExpressionValue:
	(ID | STRING | INT | DECIMAL)
;

LinkVariablePattern:
	(op = Operator)? '-' type = [ecore::EReference] '->' target = [ObjectVariablePattern]
;

Operator:
	value = ('++ ' | '! ')
;

// Auxiliaries

Import:
	'import' importedNamespace = QualifiedNameWithWildcard
;

QualifiedNameWithWildcard:
	QualifiedName '.*'
;

QualifiedName returns ecore::EString:
	ID ('.' ID)*
;
